#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    front,          sensorReflection)
#pragma config(Sensor, in8,    back,           sensorReflection)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  touch1,         sensorTouch)
#pragma config(Sensor, dgtl4,  r,              sensorTouch)
#pragma config(Sensor, dgtl5,  l,              sensorTouch)
#pragma config(Sensor, dgtl12, led,            sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           right,         tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          right,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int threshold=3000;
int cases=0;
int buttonvalue1(){
	wait1Msec(1500);
	int button;
	button=SensorValue[touch1];
	return button;
}

// reads the button value
int buttonvalue(){
	wait1Msec(2500);
	int button;
	//button=SensorValue[touch2];
	return button;
}

//makes robot go forward
void forw(){
	motor[port1]=30;
	motor[port10]=30;
}

//makes robot go backward
void backw(){
	motor[port1]=-30;
	motor[port10]=-30;
}

//stop the robot
void motorstop(){
	motor[port1]=0;
	motor[port10]=0;
}

//rotate the robot clockwise
void rotate(){
	motor[port1]=40;
	motor[port10]=-40;
}

//rotate the robot anticlockwise
void arotate(){
	motor[port1]=-40;
	motor[port10]=40;
}

// if front photo transistors detects beacon, it returns 1
int photo(){
	int flag=0;
	if((SensorValue[front]<=3550) && (SensorValue[sonar]>=50)){
		return(1);
	}
	else if((SensorValue[back]<=3600)){
		//return(2);
	}
	else if(SensorValue[front]<=3600){
		return(1);
	}

	return(0);
}


int crashtest(){
	int flag=0;
	if(SensorValue[r]==1 ||SensorValue[l]==1|| SensorValue[sonar]<=14){// if any obstacle found stop
		motorstop();
		flag=1;
	}
	if(SensorValue[r]==1){// in case right bumper is hit
		backw();
		wait1Msec(400);
		arotate();
		wait1Msec(800);
		//forw();
		//wait1Msec(400);
		motorstop();
	}
	else if(SensorValue[l]==1){// in case left bumper
		backw();
		wait1Msec(400);
		rotate();
		wait1Msec(800);
		//forw();
	 	//wait1Msec(400);
		motorstop();
	}
	else if(SensorValue[sonar]<=14){// in case sonar detects it
		backw();
		wait1Msec(800);
		motorstop();
	}
	return flag;
}

int crashtest2(){// very similar to crashtest(). It doesn't use sonar to detect obstacle at frontS
	int flag=0;
	if(SensorValue[r]==1 ||SensorValue[l]==1){// in case hit, stop
		motorstop();
		flag=1;
	}
	if(SensorValue[r]==1){// right bumper hit, backup and rotate
		backw();
		wait1Msec(400);
		arotate();
		wait1Msec(800);
		//forw();
		//wait1Msec(400);
		motorstop();
	}
	else if(SensorValue[l]==1){// left sensor hit, back and rotate
		backw();
		wait1Msec(400);
		rotate();
		wait1Msec(800);
		//forw();
	 	//wait1Msec(400);
		motorstop();
	}
	return flag;
}

void dropmech(){ // carries out the drop mechanism and moves the robot backward, away from the beacon when task finished
	motor[port2]=-40;
	wait1Msec(5000);
	backw();
	wait1Msec(500);
	rotate();
	wait1Msec(1000);
	backw();
	wait1Msec(200);
}


int searchcycle(){// searches for the beacon, then approaches it
	int flag=photo();
	int crash; //keep track of crash. if crash happens then crash=1
	while(flag==0){// will roate till beacon detectd
		flag=photo();
		if(!(flag==0)){
			motorstop();
			break;
		}
		rotate();
		crash=crashtest(); //stops the robot in case of crash and search cycle restarts
		if(crash==1){
			break;
		}

	}
	/*if(flag==2){
		rotate();
		wait1Msec(390);
		crash=crashtest();
	} */
	if(crash==1){
		return(13); //crash happened, function will stop and return 13
	}
	while(SensorValue[sonar]>=16){
		forw(); //moving towards robot
		crash= crashtest2();
		if(crash==1){
			return(13); //if crashed then function stops and return 13
		}
		if(SensorValue[sonar]<=16){
			motorstop(); //if robot is close enough to the beacon then stop
		}
	}
	motorstop();
	return flag;
}


task main()
{
	int i=0; // to initiate search cycle twice
	motorstop();
	int j=0;
	while(j==0){
		SensorValue[led]=0;
		int crash=0;
		if(crash==13){
			searchcycle(); //if robot crashed then search again
		}
		if(buttonvalue1()){
			cases=1;
		}
		if(cases==1){
			crash=searchcycle(); //crash will get 1 if beacon found, 13 if collision happened.
			if(!(crash==13)){
				if(i==1){
					cases=2; //if searh cycle has happened twice then make case=2
				}
				i++;
			}
			if(cases==2){ //if case is 2 then robot is ready to initiate drop mech.
				dropmech();
				SensorValue[led]=1;
				wait1Msec(2000);
				motor[port3]=90;
				wait1Msec(5000);
				break;
			}
		}
	}
}
